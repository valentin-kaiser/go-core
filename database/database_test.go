package database_test

import (
	"context"
	"database/sql"
	"errors"
	"os"
	"path/filepath"
	"sync/atomic"
	"testing"
	"time"

	_ "github.com/mattn/go-sqlite3"
	"github.com/valentin-kaiser/go-core/database"
	"github.com/valentin-kaiser/go-core/flag"
	"github.com/valentin-kaiser/go-core/logging"
)

// DBTX interface is typically generated by sqlc
type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// TestQueries is a mock sqlc Queries type for testing
type TestQueries struct {
	db DBTX
}

// NewTestQueries creates a new TestQueries instance
func NewTestQueries(db DBTX) *TestQueries {
	return &TestQueries{db: db}
}

// TestNew tests creating a new database instance
func TestNew(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")
	if db == nil {
		t.Fatal("New() returned nil")
	}

	if db.Connected() {
		t.Error("New database should not be connected")
	}
}

// TestDatabase_Connect_SQLite tests connecting to SQLite database
func TestDatabase_Connect_SQLite(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()

	// Wait for connection
	db.AwaitConnection()

	if !db.Connected() {
		t.Error("Database should be connected")
	}

	sqlDB := db.Get()
	if sqlDB == nil {
		t.Error("Get() should return a valid database connection")
	}
}

// TestDatabase_Connect_InvalidConfig tests connecting with invalid config
func TestDatabase_Connect_InvalidConfig(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := "invalid://connection"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()

	// Wait a bit
	time.Sleep(300 * time.Millisecond)

	// Should not be connected with invalid config
	if db.Connected() {
		t.Error("Database should not be connected with invalid config")
	}
}

// TestDatabase_Disconnect tests disconnecting from database
func TestDatabase_Disconnect(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-disconnect")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	db.AwaitConnection()

	if !db.Connected() {
		t.Fatal("Database should be connected")
	}

	err := db.Disconnect()
	if err != nil {
		t.Errorf("Disconnect() returned error: %v", err)
	}

	// Give it a moment to actually disconnect
	time.Sleep(50 * time.Millisecond)

	// Note: Connected() may still return true briefly due to async nature
	// The important part is that Disconnect() returned without error
}

// TestDatabase_Reconnect tests reconnecting to database
func TestDatabase_Reconnect(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	db.AwaitConnection()

	if !db.Connected() {
		t.Fatal("Database should be connected")
	}

	// Reconnect with new config
	newDsn := ":memory:"
	db.Reconnect(newDsn)

	// Wait for reconnection
	time.Sleep(300 * time.Millisecond)

	if !db.Connected() {
		t.Error("Database should be connected after Reconnect()")
	}

	db.Disconnect()
}

// TestDatabase_Execute tests executing raw SQL
func TestDatabase_Execute(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Create a table
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
		return err
	})
	if err != nil {
		t.Errorf("Execute() failed: %v", err)
	}

	// Insert data
	err = db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("INSERT INTO users (name) VALUES (?)", "Alice")
		return err
	})
	if err != nil {
		t.Errorf("Execute() failed: %v", err)
	}

	// Query data
	err = db.Execute(func(sqlDB *sql.DB) error {
		var name string
		err := sqlDB.QueryRow("SELECT name FROM users WHERE id = 1").Scan(&name)
		if err != nil {
			return err
		}
		if name != "Alice" {
			t.Errorf("Expected 'Alice', got '%s'", name)
		}
		return nil
	})
	if err != nil {
		t.Errorf("Execute() failed: %v", err)
	}
}

// TestDatabase_Execute_NotConnected tests executing when not connected
func TestDatabase_Execute_NotConnected(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	err := db.Execute(func(sqlDB *sql.DB) error {
		return nil
	})
	if err == nil {
		t.Error("Execute() should fail when not connected")
	}
}

// TestDatabase_Query tests using sqlc queries
func TestDatabase_Query(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-query")
	db.RegisterQueries(NewTestQueries)

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Create a table first
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)")
		return err
	})
	if err != nil {
		t.Fatalf("Failed to create table: %v", err)
	}

	// Use Query method
	err = db.Query(func(q *TestQueries) error {
		_, err := q.db.ExecContext(context.Background(), "INSERT INTO users (name) VALUES (?)", "Bob")
		return err
	})
	if err != nil {
		t.Errorf("Query() failed: %v", err)
	}
}

// TestDatabase_Query_NotRegistered tests Query without registered constructor
func TestDatabase_Query_NotRegistered(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	err := db.Query(func(q *TestQueries) error {
		return nil
	})
	if err == nil {
		t.Error("Query() should fail when queries constructor not registered")
	}
}

// TestDatabase_Transaction tests database transactions
func TestDatabase_Transaction(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Create table
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE accounts (id INTEGER PRIMARY KEY, balance INTEGER)")
		if err != nil {
			return err
		}
		_, err = sqlDB.Exec("INSERT INTO accounts (id, balance) VALUES (1, 100), (2, 100)")
		return err
	})
	if err != nil {
		t.Fatalf("Failed to setup table: %v", err)
	}

	// Successful transaction
	err = db.Transaction(func(tx *sql.Tx) error {
		_, err := tx.Exec("UPDATE accounts SET balance = balance - 50 WHERE id = 1")
		if err != nil {
			return err
		}
		_, err = tx.Exec("UPDATE accounts SET balance = balance + 50 WHERE id = 2")
		return err
	})
	if err != nil {
		t.Errorf("Transaction() failed: %v", err)
	}

	// Verify transaction was committed
	err = db.Execute(func(sqlDB *sql.DB) error {
		var balance int
		err := sqlDB.QueryRow("SELECT balance FROM accounts WHERE id = 1").Scan(&balance)
		if err != nil {
			return err
		}
		if balance != 50 {
			t.Errorf("Expected balance 50, got %d", balance)
		}
		return nil
	})
	if err != nil {
		t.Errorf("Failed to verify transaction: %v", err)
	}
}

// TestDatabase_Transaction_Rollback tests transaction rollback
func TestDatabase_Transaction_Rollback(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-rollback")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Create table
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE IF NOT EXISTS accounts (id INTEGER PRIMARY KEY, balance INTEGER)")
		if err != nil {
			return err
		}
		_, err = sqlDB.Exec("INSERT OR REPLACE INTO accounts (id, balance) VALUES (1, 100)")
		return err
	})
	if err != nil {
		t.Fatalf("Failed to setup table: %v", err)
	}

	// Failed transaction (should rollback)
	err = db.Transaction(func(tx *sql.Tx) error {
		_, err := tx.Exec("UPDATE accounts SET balance = balance - 50 WHERE id = 1")
		if err != nil {
			return err
		}
		return errors.New("intentional error")
	})
	if err == nil {
		t.Error("Transaction() should return error")
	}

	// Verify transaction was rolled back
	err = db.Execute(func(sqlDB *sql.DB) error {
		var balance int
		err := sqlDB.QueryRow("SELECT balance FROM accounts WHERE id = 1").Scan(&balance)
		if err != nil {
			return err
		}
		if balance != 100 {
			t.Errorf("Expected balance 100 (rolled back), got %d", balance)
		}
		return nil
	})
	if err != nil {
		t.Errorf("Failed to verify rollback: %v", err)
	}
}

// TestDatabase_RegisterOnConnectHandler tests on-connect handlers
func TestDatabase_RegisterOnConnectHandler(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	var handlerCalled atomic.Bool
	db.RegisterOnConnectHandler(func(sqlDB *sql.DB) error {
		handlerCalled.Store(true)
		_, err := sqlDB.Exec("CREATE TABLE test_table (id INTEGER PRIMARY KEY)")
		return err
	})

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	if !handlerCalled.Load() {
		t.Error("OnConnect handler should have been called")
	}

	// Verify table was created
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("INSERT INTO test_table (id) VALUES (1)")
		return err
	})
	if err != nil {
		t.Errorf("Table created by handler should exist: %v", err)
	}
}

// TestDatabase_RegisterOnConnectHandler_Nil tests registering nil handler
func TestDatabase_RegisterOnConnectHandler_Nil(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	// Should not panic
	db.RegisterOnConnectHandler(nil)

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	if !db.Connected() {
		t.Error("Database should be connected even with nil handler")
	}
}

// TestDatabase_RegisterMiddleware tests middleware registration
func TestDatabase_RegisterMiddleware(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	logger := logging.NewNoOpAdapter()
	mw := database.NewLoggingMiddleware(logger)

	result := db.RegisterMiddleware(mw)
	if result != db {
		t.Error("RegisterMiddleware should return the same instance")
	}

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Execute query to verify middleware is working
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("SELECT 1")
		return err
	})
	if err != nil {
		t.Errorf("Execute with middleware failed: %v", err)
	}
}

// TestDatabase_RegisterQueries tests registering queries constructor
func TestDatabase_RegisterQueries(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	result := db.RegisterQueries(NewTestQueries)
	if result != db {
		t.Error("RegisterQueries should return the same instance")
	}

	// Test with nil
	result = db.RegisterQueries(nil)
	if result != db {
		t.Error("RegisterQueries with nil should return the same instance")
	}
}

// TestDatabase_Debug tests debug mode
func TestDatabase_Debug(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-debug")
	db.RegisterQueries(NewTestQueries)

	logger := logging.NewNoOpAdapter()
	loggingMw := database.NewLoggingMiddleware(logger)
	loggingMw.SetEnabled(false) // Disable by default
	db.RegisterMiddleware(loggingMw)

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Create table
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)")
		return err
	})
	if err != nil {
		t.Fatalf("Failed to create table: %v", err)
	}

	// Regular execute (logging disabled)
	err = db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("INSERT INTO users (name) VALUES ('Alice')")
		return err
	})
	if err != nil {
		t.Errorf("Execute failed: %v", err)
	}

	// Debug execute (logging should be temporarily enabled)
	err = db.Debug().Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("INSERT INTO users (name) VALUES ('Bob')")
		return err
	})
	if err != nil {
		t.Errorf("Debug().Execute() failed: %v", err)
	}

	// Debug query
	err = db.Debug().Query(func(q *TestQueries) error {
		_, err := q.db.ExecContext(context.Background(), "INSERT INTO users (name) VALUES (?)", "Charlie")
		return err
	})
	if err != nil {
		t.Errorf("Debug().Query() failed: %v", err)
	}
}

// TestDatabase_Debug_WithoutMiddleware tests debug mode without middleware
func TestDatabase_Debug_WithoutMiddleware(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-debug-no-mw")
	db.RegisterQueries(NewTestQueries)

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Create table
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)")
		return err
	})
	if err != nil {
		t.Fatalf("Failed to create table: %v", err)
	}

	// Debug without LoggingMiddleware should fail
	err = db.Debug().Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("INSERT INTO users (name) VALUES ('Alice')")
		return err
	})
	if err == nil {
		t.Error("Debug().Execute() should fail without LoggingMiddleware")
	}
}

// TestDatabase_Backup_SQLite tests backup functionality for SQLite
func TestDatabase_Backup_SQLite(t *testing.T) {
	// Initialize flag package for path
	flag.Init()

	// Ensure the data directory exists
	if err := os.MkdirAll(flag.Path, 0750); err != nil {
		t.Fatalf("Failed to create data directory: %v", err)
	}

	db := database.New[TestQueries](database.DriverSQLite, "test")

	// Use a DSN with file: prefix (required for backup functionality)
	dbPath := filepath.Join(flag.Path, "test_backup.db")
	dsn := "file:" + dbPath

	db.Connect(100*time.Millisecond, dsn)
	defer func() {
		db.Disconnect()
		// Clean up test database file
		os.Remove(dbPath)
		os.Remove(dbPath + "-wal")
		os.Remove(dbPath + "-shm")
	}()
	db.AwaitConnection()

	// Create table and insert data
	err := db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)")
		if err != nil {
			return err
		}
		_, err = sqlDB.Exec("INSERT INTO users (name) VALUES ('Alice'), ('Bob')")
		return err
	})
	if err != nil {
		t.Fatalf("Failed to setup database: %v", err)
	}

	// Backup database
	backupPath := filepath.Join(flag.Path, "test_backup_file.db")
	defer os.Remove(backupPath)

	err = db.Backup(backupPath, "")
	if err != nil {
		t.Errorf("Backup() failed: %v", err)
	}

	// Verify backup file exists
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		t.Error("Backup file should exist")
	}
}

// TestDatabase_Backup_InMemory tests backup with in-memory database
func TestDatabase_Backup_InMemory(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	err := db.Backup("backup.db", "")
	if err == nil {
		t.Error("Backup() should fail for in-memory database")
	}
}

// TestDatabase_Restore_SQLite tests restore functionality for SQLite
func TestDatabase_Restore_SQLite(t *testing.T) {
	flag.Init()

	// Create original database
	db1 := database.New[TestQueries](database.DriverSQLite, "test1")
	dsn1 := "file:test_restore_orig.db"

	db1.Connect(100*time.Millisecond, dsn1)
	defer func() {
		db1.Disconnect()
		os.Remove(filepath.Join(flag.Path, "test_restore_orig.db"))
		os.Remove(filepath.Join(flag.Path, "test_restore_orig.db-wal"))
		os.Remove(filepath.Join(flag.Path, "test_restore_orig.db-shm"))
	}()
	db1.AwaitConnection()

	// Create table and insert data
	err := db1.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)")
		if err != nil {
			return err
		}
		_, err = sqlDB.Exec("INSERT INTO users (name) VALUES ('Original')")
		return err
	})
	if err != nil {
		t.Fatalf("Failed to setup database: %v", err)
	}

	// Backup
	backupPath := filepath.Join(flag.Path, "test_restore_backup.db")
	defer os.Remove(backupPath)

	err = db1.Backup(backupPath, "")
	if err != nil {
		t.Fatalf("Backup failed: %v", err)
	}

	// Create new database
	db2 := database.New[TestQueries](database.DriverSQLite, "test2")
	dsn2 := "file:test_restore_target.db"

	db2.Connect(100*time.Millisecond, dsn2)
	defer func() {
		db2.Disconnect()
		os.Remove(filepath.Join(flag.Path, "test_restore_target.db"))
		os.Remove(filepath.Join(flag.Path, "test_restore_target.db-wal"))
		os.Remove(filepath.Join(flag.Path, "test_restore_target.db-shm"))
	}()
	db2.AwaitConnection()

	// Restore
	err = db2.Restore(backupPath)
	if err != nil {
		t.Errorf("Restore() failed: %v", err)
	}

	// Wait for reconnection after restore
	time.Sleep(300 * time.Millisecond)
	db2.AwaitConnection()

	// Verify data was restored
	err = db2.Execute(func(sqlDB *sql.DB) error {
		var name string
		err := sqlDB.QueryRow("SELECT name FROM users WHERE id = 1").Scan(&name)
		if err != nil {
			return err
		}
		if name != "Original" {
			t.Errorf("Expected 'Original', got '%s'", name)
		}
		return nil
	})
	if err != nil {
		t.Errorf("Failed to verify restore: %v", err)
	}
}

// TestDatabase_Connected tests Connected method
func TestDatabase_Connected(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	if db.Connected() {
		t.Error("New database should not be connected")
	}

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	if !db.Connected() {
		t.Error("Database should be connected after Connect()")
	}
}

// TestDatabase_Get tests Get method
func TestDatabase_Get(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	if db.Get() != nil {
		t.Error("Get() should return nil when not connected")
	}

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	sqlDB := db.Get()
	if sqlDB == nil {
		t.Error("Get() should return valid connection when connected")
	}

	// Verify connection works
	err := sqlDB.Ping()
	if err != nil {
		t.Errorf("Ping failed: %v", err)
	}
}

// TestDatabase_AwaitConnection tests AwaitConnection method
func TestDatabase_AwaitConnection(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test")

	dsn := ":memory:"

	start := time.Now()
	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()

	// This should block until connected
	db.AwaitConnection()
	elapsed := time.Since(start)

	if !db.Connected() {
		t.Error("Database should be connected after AwaitConnection()")
	}

	// Should have taken some time to connect
	if elapsed < 50*time.Millisecond {
		t.Log("AwaitConnection returned very quickly, connection may have been instant")
	}
}

// BenchmarkDatabase_Execute benchmarks Execute method
func BenchmarkDatabase_Execute(b *testing.B) {
	db := database.New[TestQueries](database.DriverSQLite, "bench")
	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Setup
	db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE bench (id INTEGER PRIMARY KEY, value TEXT)")
		return err
	})

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		db.Execute(func(sqlDB *sql.DB) error {
			_, err := sqlDB.Exec("INSERT INTO bench (value) VALUES (?)", "test")
			return err
		})
	}
}

// BenchmarkDatabase_Query benchmarks Query method
func BenchmarkDatabase_Query(b *testing.B) {
	db := database.New[TestQueries](database.DriverSQLite, "bench")
	db.RegisterQueries(NewTestQueries)

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Setup
	db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE bench (id INTEGER PRIMARY KEY, value TEXT)")
		return err
	})

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		db.Query(func(q *TestQueries) error {
			_, err := q.db.ExecContext(context.Background(), "INSERT INTO bench (value) VALUES (?)", "test")
			return err
		})
	}
}

// BenchmarkDatabase_Transaction benchmarks Transaction method
func BenchmarkDatabase_Transaction(b *testing.B) {
	db := database.New[TestQueries](database.DriverSQLite, "bench")
	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	// Setup
	db.Execute(func(sqlDB *sql.DB) error {
		_, err := sqlDB.Exec("CREATE TABLE bench (id INTEGER PRIMARY KEY, value TEXT)")
		return err
	})

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		db.Transaction(func(tx *sql.Tx) error {
			_, err := tx.Exec("INSERT INTO bench (value) VALUES (?)", "test")
			return err
		})
	}
}

// BenchmarkDatabase_Get benchmarks Get method
func BenchmarkDatabase_Get(b *testing.B) {
	db := database.New[TestQueries](database.DriverSQLite, "bench")
	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = db.Get()
	}
}

// BenchmarkDatabase_Connected benchmarks Connected method
func BenchmarkDatabase_Connected(b *testing.B) {
	db := database.New[TestQueries](database.DriverSQLite, "bench")
	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = db.Connected()
	}
}

// TestDatabase_Transaction_NotConnected tests transaction when not connected
func TestDatabase_Transaction_NotConnected(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-tx-not-connected")

	err := db.Transaction(func(tx *sql.Tx) error {
		return nil
	})
	if err == nil {
		t.Error("Transaction() should fail when not connected")
	}
}

// TestDatabase_Debug_Chaining tests debug mode returns same instance when already in debug
func TestDatabase_Debug_Chaining(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-debug-chain")

	debug1 := db.Debug()
	debug2 := debug1.Debug()

	if debug1 != debug2 {
		t.Error("Debug() should return same instance when already in debug mode")
	}
}

// TestDatabase_Execute_WithError tests Execute with function that returns error
func TestDatabase_Execute_WithError(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-exec-error")

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	expectedErr := errors.New("test error")
	err := db.Execute(func(sqlDB *sql.DB) error {
		return expectedErr
	})
	if err != expectedErr {
		t.Errorf("Execute() should return the error from the function, got %v", err)
	}
}

// TestDatabase_Query_WithError tests Query with function that returns error
func TestDatabase_Query_WithError(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-query-error")
	db.RegisterQueries(NewTestQueries)

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	expectedErr := errors.New("test error")
	err := db.Query(func(q *TestQueries) error {
		return expectedErr
	})
	if err != expectedErr {
		t.Errorf("Query() should return the error from the function, got %v", err)
	}
}

// TestDatabase_MultipleOnConnectHandlers tests multiple handlers
func TestDatabase_MultipleOnConnectHandlers(t *testing.T) {
	db := database.New[TestQueries](database.DriverSQLite, "test-multi-handlers")

	var handler1Called atomic.Bool
	var handler2Called atomic.Bool

	db.RegisterOnConnectHandler(func(sqlDB *sql.DB) error {
		handler1Called.Store(true)
		return nil
	})

	db.RegisterOnConnectHandler(func(sqlDB *sql.DB) error {
		handler2Called.Store(true)
		return nil
	})

	dsn := ":memory:"

	db.Connect(100*time.Millisecond, dsn)
	defer db.Disconnect()
	db.AwaitConnection()

	if !handler1Called.Load() {
		t.Error("First handler should have been called")
	}
	if !handler2Called.Load() {
		t.Error("Second handler should have been called")
	}
}
